{
  "_id": "5a30df91f5a2940037e5a54f",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"Identify with Remote Second\" capability\n      // order_level:0.0.1:local:382hf273\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      switch(inputAction){\n        \n        case 'talk':\n        case 'send':\n            \n            // inputOpts\n          \n          let { ExternalIdentityNode, RequestNode } = inputOpts;\n          \n          // Need to create a local Identity, and authenticate with the remote Second to Learn from \n          // - uses a constant value (token) from the remote Second! \n          let nodeResponse = await universe.loadAndRunCapability('Request',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'make',\n              options: {\n                ExternalIdentityNode,\n                RequestNode\n              }\n            }\n          });\n          \n          return resolve(nodeResponse);\n            \n          // let nodeResponse = await universe. TalkToSecond({\n          //   ExternalIdentityNode: INPUT,\n          //   InputNode: {\n          //     type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n          //     data: {\n          //       actions: [\n          //         {\n          //           matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n          //           dataForAction: {\n          //             type: 'standard_query_request:0.0.1:local:65723f2khfds',\n          //             data: {\n          //               matchFunctionNode: {\n          //                 // query here!\n          //                 // action_pointer:0.0.1:local:238972ncr\n          //                 type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n          //                 data: {\n          //                   code: codeSearchTemplate\n          //                 }\n          //               },\n          //               // expected/allowed schemas for return \n          //               // outputSchemas: [\n          //               //   'query_result:0.0.1:local:32490usfj23o23f',\n          //               //   'internal_error_output:0.0.1:local:32948x2u3cno2c'\n          //               // ]\n          //             }\n          //           }\n          //         }\n          //       ]\n                \n          //     }\n          //   }\n          // });\n          \n          \n        default:\n          break;\n      }\n      \n      return reject();\n      \n      \n      \n      // Currently ExternalIdentity is unique by the publicKey (cant have multiple identities with the same publicKey) \n      // - can have multiple connect_method's though! (websocket, etc.) \n      \n      // // INPUT: \n      // {\n      //   type: 'key_public:0.0.1:local:3928fhj2389f',\n      //   data: 'string'\n      // }\n      \n      \n      // Initiates a challenge with an external Second \n      // - ExternalIdentity should ALREADY EXIST locally! \n      //   - look it up from nodes by INPUT.data.publicKey \n      // - lookup by data:publicKey, childNode:type:connect_method \n      // - checks for local ExternalIdentity first! \n      // - \n      \n      return resolve({\n        INPUT\n      });\n      \n      \n      \n      \n      \n      // Get local ExternalIdentity if it exists \n      let nodes = await universe.searchMemory({\n        filter: {\n          sqlFilter: {\n            type: 'external_identity:0.0.1:local:8982f982j92',\n            data: {\n              publicKey: INPUT.data\n            }\n          },\n          // function for returning data from the Node, after filtering a bit \n          // - includes both the Node, and Nodes with nodeId (pointers) \n          filterNodes: tmpNodes=>{\n            return tmpNodes;\n          }\n        }\n      });\n      \n      if(!nodes.length){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity node',\n            publicKey: INPUT.data\n          }\n        })\n      }\n      \n      let ExternalIdentityNode = nodes[0];\n      // else {\n      //   ExternalIdentityNode = {\n      //     // no _id yet! (will create/update later!) \n      //     type: 'external_identity:0.0.1:local:8982f982j92',\n      //     data: {\n      //       publicKey:INPUT.data\n      //     }\n      //   }\n      // }\n      \n      // has connect_method (external_identity_connect_method:0.0.1:local:382989239hsdfmn)?\n      let connectNode = universe.lodash.find(ExternalIdentityNode.nodes, {type: 'external_identity_connect_method:0.0.1:local:382989239hsdfmn'});\n      if(!connectNode){\n        return resolve({\n          type: 'internal_error_output:0.0.1:local:32948x2u3cno2c',\n          data: {\n            str: 'Missing existing ExternalIdentity connect_method child!'\n          }\n        })\n      }\n      \n      \n      \n      // Initiate Auth Steps \n      // - send my publicKey, new challengeText that we want validated \n      let MyPrivateIdentity = await universe.capabilities().privateIdentity();\n      let myPublicKey = MyPrivateIdentity.data.public;\n      let newChallenge = universe.uuidv4();\n      \n      universe.console.log('Created NewChallenge:', newChallenge);\n      \n      // make Node request to datasource\n      let InitiateIdentifyNode = {\n        type: 'challenge_initiate_info:0.0.1:local:323023424234324dwf',\n        data: {\n          publicKey: myPublicKey,\n          challenge: newChallenge\n        }\n      }\n      let WrappedInitiateIdentifyNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_start:0.0.1:local:3892fh83h46',\n          dataForAction: InitiateIdentifyNode\n        }\n      }\n      \n      let ExternalInitialResponseNodeFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedInitiateIdentifyNode\n        }\n      });\n      // response includes the \"output_generic\" wrapper \n      let ExternalInitialResponseNode = ExternalInitialResponseNodeFull.data;\n      \n      // // successful response: challenge_start_response\n      // return resolve({\n      //   ok: 'test1',\n      //   response: ExternalInitialResponse\n      // });\n      \n      // Received:\n      // - answered challenge, signed using Private Key of External, verify using their PublicKey \n      // - new challenge for me to answer (to verify myself!), so I can get a JWT! \n      // - \n      \n      \n      // Verify challenge I sent \n      let verified = await universe.capabilities().verify({\n        type: 'challenge_verify:0.0.1:local:93fj92hj832ff2',\n        data: {\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        }\n      });\n      // boolean Node is returned\n      if(!verified.data){\n        return resolve({\n          err: 'Failed verifiation!',\n          challenge: newChallenge,\n          solution: ExternalInitialResponseNode.data.solution,\n          publicKey: ExternalIdentityNode.data.publicKey\n        });\n      }\n      \n      \n      // return resolve({\n      //   verified: verified\n      // });\n      \n      \n      // Verified external! \n      // - now need to identify myself, by answering the challenge I was sent \n      // - really this could be completed in reverse (but might as well just do it here!) \n      //   - better to do it in a handshake, otherwise the External might just say \"I was only holding your info for a moment and I got tired of holding it while I didn't know who you were\" \n      let SignedNode = await universe.capabilities().sign({\n        type: 'string:0.0.1:local:289hf329h93',\n        data: ExternalInitialResponseNode.data.challenge\n      });\n      \n      // Make Node request to External, using my publicKey and the challenge/solution I was sent \n      // - getting a JWT back! \n      let GetIdentityTokenNode = {\n        type: 'challenge_get_token:0.0.1:local:9238f9hf923',\n        data: {\n          publicKey: myPublicKey,\n          challengeReceived: ExternalInitialResponseNode.data.challenge,\n          solution: SignedNode.data // base64 string \n        }\n      }\n      let WrappedTokenNode = {\n        type: 'run_action:0.0.1:local:2398y294c23',\n        data: {\n          matchActionType: 'identify_challenge_response:0.0.1:local:3289h988h293fh8h',\n          dataForAction: GetIdentityTokenNode\n        }\n      }\n      let ExternalTokenResponseFull = await universe.capabilities().externalRequest({\n        type: 'external_request_info:0.0.1:local:329fj239832h93f23',\n        data: {\n          ExternalIdentityNode, // must include connect_method\n          RequestNode: WrappedTokenNode\n        }\n      });\n      \n      // return resolve({\n      //   x: 1,\n      //   ExternalTokenResponseFull\n      // });\n      \n      // response includes the \"output_generic\" wrapper \n      let ExternalTokenResponseNode = ExternalTokenResponseFull.data;\n      \n      // save updated ExternalIdentityNode\n      ExternalIdentityNode.data.token = ExternalTokenResponseNode.data.token; // assuming Node response w/ encrypted token as data\n      let updatedExternalIdentityNode = await universe.updateNode(ExternalIdentityNode);\n      // todo: save\n      \n      // check for publicKey info (ok to allow this person?) \n      // - after I send them something to sign and actually get their identity...\n      \n      resolve({\n        type: 'challenge_finish:0.0.1:local:2983jf982',\n        data: {\n          SUCCESS: {\n            ExternalInitialResponseNode,\n            ExternalTokenResponseNode,\n            SignedNode_data: SignedNode.data,\n            updatedExternalIdentityNode\n          }\n        }\n      });\n        \n        \n    }catch(err){\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "note": "Capability: TalkToSecond",
    "key": "e7af1532-eb2b-45f6-8673-79199855e487"
  },
  "active": true,
  "createdAt": 1513152401168,
  "updatedAt": 1513152581648
}