{
  "_id": "5a347b88a9641f0026f7e839",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "key": "97babb15-ed8d-42a5-ae26-b197c308189a",
    "internalId": "MainCommandsComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            inputText: '',\n            matches: [], // match results\n            searching: false,\n            searched: false,\n            editingNode: null\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Mounted MainCommandsComponent');\n          \n          return new Promise(async (resolve,reject)=>{\n            \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            this.props.setState({\n              OwnerSecondExternalIdentityNode: ExternalIdentityNode\n            });\n            \n            // Load component for matches \n            let UserCommandMatchesComponent = await this.props.loadComponent({\n              internalId: 'UserCommandMatchesComponent'\n            });\n            this.setState({\n              UserCommandMatchesComponent\n            })\n            \n            // Load component for editing \n            let EditingPhraseComponent = await this.props.loadComponent({\n              internalId: 'EditingPhraseComponent'\n            });\n            this.setState({\n              EditingPhraseComponent\n            })\n            \n            \n            this.fetchPrivateName();\n          \n          });\n          \n          try {\n            this.inputRef.focus();\n          }catch(err){\n          }\n          \n        }\n        \n        @autobind\n        fetchPrivateName(){\n          \n          return new Promise(async (resolve, reject)=>{\n              \n            let ExternalIdentityNodes = await universe.searchMemory({\n              filter: {\n                sqlFilter: {\n                  type: 'external_identity:0.0.1:local:8982f982j92',\n                  data: {\n                    commonName: 'main'\n                  }\n                }\n              }\n            });\n            let ExternalIdentityNode = ExternalIdentityNodes[0];\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != 'identity_private:0.0.1:local:3298f2j398233'){\n                                        return false;\n                                      }\n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let nodes = response.data.actionResponses[0].data;\n              \n              let privateNode = nodes[0];\n              console.log('PrivateNode:', privateNode);\n              \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.props.setState({\n                privateNode\n              })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          });\n        }\n        \n        @autobind\n        handleTest(){\n          this.setState({\n            value: this.state.value + 1\n          })\n        }\n        \n        @autobind\n        async handleClearMemory(){\n          \n          await universe.clearMemory();\n          WINDOW.location.reload();\n          \n        }\n        \n        @autobind\n        handleKeyDown(e){\n        \n          if(e.key && e.key.toLowerCase() == 'enter'){\n            \n            this.handleTextCommand();\n            \n          } \n        }\n        \n        @autobind\n        handleTextCommand(){\n          \n          return new Promise(async (resolve, reject)=>{\n              \n            let text = universe.lodash.trim(this.state.inputText);\n            if(!text || !text.length){\n              return false;\n            }\n            \n            this.setState({\n              searching: true,\n              searched: false,\n              editingNode: false,\n              ActionComponent: null\n            })\n            \n            // Make request to remote Second \n            // - pass along context Nodes \n            let nodeForInput = {\n              type: 'user_text_command:0.0.1:local:829j91800012',\n              data: {\n                text: text,\n                // context nodes for additional parsing information (what I'm doing, etc?) \n                contextNodes: [\n                  {\n                    type: '',\n                    data: ''\n                  }\n                ]\n              }\n            }\n            \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'user_text_command:0.0.1:local:829j91800012',\n                            dataForAction: nodeForInput\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              let actionResponseData = response.data.actionResponses[0].data;\n              \n              console.log('actionResponseData:', actionResponseData);\n              \n              // matches are stored \n              \n              this.setState({\n                searching: false,\n                searched: true,\n                matches: actionResponseData.matches,\n                nodeFromInput: {\n                  type: 'string:...',\n                  data: {\n                    text: text\n                  }\n                }\n                // editingNodes: actionResponseData.parsed // is an array of possible actions to run! \n              })\n              \n            }catch(err){\n              console.error('Failed user_text_command:', err);\n            }\n            \n          });\n            \n        }\n        \n        @autobind\n        updateInput(text){\n          this.setState({\n            inputText: text\n          })\n          this.inputRef.focus();\n        }\n        \n        @autobind\n        handleActionComponent(node, ActionComponent){\n          // updates the Action component being displayed \n          // - it is supposed to \"manage\" itself! \n          \n          this.setState({\n            ActionComponent\n          });\n          \n        }\n        \n        @autobind\n        handleVoiceInput(inputText, recognition, complete){\n          \n          let startWord = 'testing';\n          let stopWords = [\n            startWord + ' stop',\n            startWord + ' abort',\n            'i said nevermind',\n            'stop listening',\n            'stop stop stop',\n            'nevermind',\n            startWord + ' never mind',\n          ];\n            \n          console.log('handleVoiceInput', inputText, complete, this.state.isInputting); \n          \n          // found startword? \n          if(this.state.isInputting){\n            // still inputting (might be done!)  \n          } else {\n            // is startword found?\n            if(inputText.toLowerCase().indexOf(startWord) > -1){\n              // found it in the latest text! \n              // - restart listener\n              console.log('STOPPing listening'); \n              recognition.stop();\n              recognition.newRecognition(true);\n              console.log('Started re-listening');\n              this.setState({\n                isInputting: true\n              });\n              return false;\n              \n            } else {\n              // not found\n              console.log('no startword found');\n              return false;\n            }\n          }\n          \n          // check for stopwords \n          stopWords.forEach(phrase=>{\n            if(!inputText || !inputText.length){\n              return;\n            }\n            if(inputText.indexOf(phrase) > -1){\n              inputText = '';\n              complete = true;\n              recognition.stop();\n              recognition.newRecognition(true);\n            }\n          })\n          \n          this.setState({\n            inputText,\n            isInputting: complete === true ? false:true,\n          }, complete ? ()=>{\n            console.log('Complete!', inputText);\n            this.handleTextCommand();\n          }:null)\n        }\n        \n        \n        render(){\n          \n          // const MainEditorComponent = this.state.mainEditor || ErrorComponent;\n          \n          // let componentCommands = await this.props.loadComponent({\n          //   internalId: 'ListComponent'\n          // });\n          // this.setState({\n          //   componentCommands\n          // })\n          \n          let EditingPhraseComponent = this.state.EditingPhraseComponent || ErrorComponent;\n          let UserCommandMatchesComponent = this.state.UserCommandMatchesComponent || ErrorComponent;\n          \n          let ActionComponent = this.state.ActionComponent;\n          \n          let defaultCommands = [\n            'connect to test20 test21',\n            'who am I connected to',\n            'show me photos from friends',\n            'tell me a joke',\n            'send grandma 50 buckaroos',\n            'call mom',\n            'lemme watch some netflix',\n            'what italian restaurants in san francisco north beach are good'\n          ];\n          \n          let editingNode = this.state.nodeFromInput;\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <h3 className=\"title is-5\">\n                  History of Commands\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  Things you've said\n                </h3>\n                \n              </div>\n              <div className=\"flex-middle\" style={{borderTop:'1px solid #eee', padding: '24px'}}>\n                \n                <div className=\"field has-addons\">\n                  <div className=\"control is-expanded\">\n                    <input \n                      ref={r=>this.inputRef=r}\n                      autoFocus={true}\n                      className={\"input \" + (this.state.isInputting ? 'is-success':'')}\n                      type=\"text\" \n                      placeholder=\"Enter text command here\" \n                      value={this.state.inputText}\n                      onChange={e=>this.setState({inputText:e.target.value})}\n                      onKeyDown={this.handleKeyDown}\n                    />\n                  </div>\n                  <div className=\"control\">\n                    <RecognitionInput\n                      onVoiceText={this.handleVoiceInput}\n                    />\n                  </div>\n                </div>\n                \n                {/* ActionComponent displays if exists */}\n                {\n                  ActionComponent ?\n                    <ActionComponent />\n                  :\n                    <div>\n                      \n                      {\n                        /* Searching */\n                        !this.state.searching ? '':\n                        <div>\n                          Fetching matches...\n                        </div>\n                      }\n                      {\n                        /* Matches */\n                        (!this.state.searched || this.state.editingNode) ? '':\n                        <div className=\"user-command-matches\">\n                          {\n                            this.state.matches.length ? \n                            <div style={{borderBottom:'1px solid #ccc'}}>\n                              <h3 className=\"title is-5\">\n                                Matches:\n                              </h3>\n                            </div>\n                            :\n                            <div>\n                              No matches! \n                            </div>\n                          }\n                          {\n                            this.state.matches.map(matchNode=>{\n                              return (\n                                <div key={matchNode._id}>\n                                \n                                  <UserCommandMatchesComponent\n                                    node={ matchNode }\n                                    handleRemove={e=>{\n                                      this.setState({\n                                        matches: universe.lodash.without(this.state.matches,matchNode)\n                                      })\n                                    }}\n                                    handleActionComponent={this.handleActionComponent}\n                                  />\n                                  \n                                </div>\n                              )\n                            })\n                          }\n                        </div>\n                      }\n                      \n                      {\n                        /*New / Editing*/\n                        !this.state.editingNode ? \n                          !this.state.searched ? '':\n                          <div style={{padding:'4px 0'}}>\n                            <button className=\"button is-info is-small\" onClick={e=>this.setState({editingNode})}>\n                              Create New Action\n                            </button>\n                          </div>\n                        :\n                          <div style={{margin:'24px 0'}}>\n                            <EditingPhraseComponent\n                              node={ this.state.editingNode }\n                              onDoneEditing={e=>this.setState({editingNode:null})}\n                            />\n                          </div>\n                      }\n                      \n                      <div className=\"content\">\n                      \n                        <ul>\n                        \n                          <li style={{marginLeft:'-30px',listStyle:'none', fontWeight:'bold'}}>\n                            Send a command: \n                          </li>\n                          \n                          {\n                            defaultCommands.map((cmd,idx)=>(\n                              <li key={idx} onClick={e=>this.updateInput(cmd)}>\n                                {cmd}\n                              </li>\n                            )) \n                          }\n                          \n                          \n                        </ul>\n                        \n                      </div>\n                    \n                    </div> \n                }\n                \n              </div>\n              <div className=\"flex-right\" style={{padding:'4px'}}>\n                \n                <h3 className=\"title is-5\">\n                  Common Inputs\n                </h3>\n                <h3 className=\"subtitle is-6\">\n                  For current sequence\n                </h3>\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n      \n      \n      const getRecognition = blob =>\n        toBase64(blob)\n          .then(base64data => base64data.substr(base64data.indexOf(',') + 1))\n          .then(remoteCall)\n          .then(res => res.json())\n          .then(res => {\n            if (!res || isEmpty(res)) {\n              return ''\n            }\n            return res.results[0].alternatives[0].transcript\n          })\n      \n      class RecognitionInput extends React.PureComponent {\n        state = {\n          data: \"\",\n          fetching: false,\n          listening: false,\n          keepListening: true\n        };\n        constructor(props){\n          super(props)\n          this.newRecognition();\n        }\n        newRecognition = (startListening) => {\n          // const recognition = universe.Speechless(\"en\", getRecognition)\n          if(this.recognition){\n            this.recognition.removeEventListener(\"start\", this.onStart); \n            this.recognition.removeEventListener(\"fetching\", this.onFetching);\n            this.recognition.removeEventListener(\"data\", this.onData);\n            this.recognition.removeEventListener(\"stop\", this.onStop);\n            this.recognition.removeEventListener(\"end\", this.onEnd);\n          }\n          delete this.recognition;\n          this.recognition = universe.Speechless(\"en\", getRecognition); //recognition;\n          console.log('new recognition', this.recognition);\n          this.recognition.newRecognition = this.newRecognition;\n          this.recognition.addEventListener(\"start\", this.onStart); \n          this.recognition.addEventListener(\"fetching\", this.onFetching);\n          this.recognition.addEventListener(\"data\", this.onData);\n          this.recognition.addEventListener(\"stop\", this.onStop);\n          this.recognition.addEventListener(\"end\", this.onEnd);\n          if(startListening){\n            this.recognition.listen();\n          }\n        };\n        onListen = () => {\n          // const { recognition } = this.props\n          console.log('onListen', this.state.listening);\n          if(this.state.listening){\n            this.setState({\n              keepListening: false,\n              listening: false\n            })\n            console.log('STOPPING recognition');\n            this.recognition.stop();\n          } else {\n            this.setState({\n              keepListening: true\n            })\n            this.recognition.listen(); \n          }\n        };\n        onFetching = e => {\n          this.setState({ fetching: true, listening: false });\n        };\n        onStart = e => {\n          this.setState({ listening: true });\n        };\n        onStop = e => {\n          console.log('forceStopped');\n          this.setState({ fetching: false, listening: false },\n          ()=>{\n            this.props.onVoiceText(this.state.data, this.recognition, true);\n            if(this.state.keepListening){\n              // this.onListen();\n              this.recognition.listen();\n            }\n          });\n        };\n        onEnd = e => {\n          console.log('Ended');\n          this.setState({ fetching: false, listening: false },\n          ()=>{\n            this.props.onVoiceText(this.state.data, this.recognition, true);\n            if(this.state.keepListening){\n              // this.onListen();\n              this.recognition.listen();\n            }\n          });\n        };\n        onData = e => {\n          this.setState({ data: e.detail });\n          this.props.onVoiceText(e.detail, this.recognition);\n        };\n        renderButton() {\n          const { fetching, listening } = this.state;\n          if (fetching) {\n            return <span className=\"icon\"><i className=\"fa fa-spinner fa-pulse\" alt=\"fetching\"></i></span>;\n          }\n          if (listening) {\n            return <span className=\"icon\"><i className=\"fa fa-microphone fa-spin\" alt=\"recording\"></i></span>;\n          }\n          return <span className=\"icon\"><i className=\"fa fa-microphone\" alt=\"mic\"></i></span>;\n        }\n        render() {\n          const { data, fetching } = this.state;\n          return (\n            <button \n              disabled={fetching}\n              className=\"button\"\n              onClick={this.onListen}>\n              {this.renderButton()}\n            </button>\n          );\n        }\n      }\n\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  },
  "active": true,
  "createdAt": 1513388936588,
  "updatedAt": 1514418991382
}