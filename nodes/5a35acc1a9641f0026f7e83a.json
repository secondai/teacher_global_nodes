{
  "_id": "5a35acc1a9641f0026f7e83a",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "key": "7f950e70-f17c-4268-a0f6-1ba848893066",
    "internalId": "MainEditorComponent",
    "note": "user_editor",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            mainTab: '__ALL__',\n            aceHeight: 100,\n            windowHeight: 100,\n            pastable: false,\n            pasteText: ''\n          }\n        }\n        \n        componentDidMount(){\n          this.resizeAce();\n          this.handleKeyDown();\n          this.loadSchema(this.props.node.type);\n          this.fetchParentsOfNodesToLearn();\n          \n          universe.EE.on('nodes-modified', this.fetchParentsOfNodesToLearn);\n          \n        }\n        \n        componentWillReceiveProps(nextProps, nextState){\n          \n          // resizing helpers for Ace height\n          if(!nextProps.state.newWindowSize || \n            this.state.windowHeight != nextProps.state.newWindowSize[1]){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          if(nextState.aceHeight == -1){\n            this.setState({\n              aceHeight: 0\n            },()=>{\n              this.resizeAce();\n            })\n          }\n          // if(nextProps.state.editingNode && this.props.node){\n          //   if(nextProps.state.editingNode._id != this.props.node._id){\n          //     this.setState({\n          //       mainTab: '__ALL__'\n          //     })\n          //   }\n          // }\n          // console.log('nextProps:', nextProps);\n        }\n        \n        componentWillUnmount(){\n          \n          universe.EE.removeListener('nodes-modified', this.fetchParentsOfNodesToLearn);\n          \n        }\n        \n        @autobind\n        resizeAce(){\n          if(!this.parentRef){\n            this.setState({\n              aceHeight: null\n            })\n            return;\n          }\n          // console.log('Resize ace', this.parentRef.offsetHeight);\n          this.setState({\n            aceHeight: this.parentRef.offsetHeight\n          },()=>{\n            if(this.aceRef){\n              this.aceRef.editor.resize();\n            }\n          })\n        }\n      \n        @autobind\n        loadSchema(slug){\n          // from Languages server \n      \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{\"slug\":\"'+slug+'\"},\"query\":\"query ($slug: String) {  viewer { language { one(filter: {slug: $slug}) {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}}}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://lang.second.ngrok.io/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.viewer.language.one){\n                console.error('Missing Schema for this type!');\n                this.setState({\n                  schema: false\n                })\n                return;\n              }\n              console.log('have Schema:', languageResult);\n              \n              let schemaObj = languageResult.data.viewer.language.one.schemaObj;\n              \n              // choose default tab if exists\n              let mainTab = this.state.mainTab;\n              try {\n                if(schemaObj.properties.code){\n                  mainTab = 'code';\n                }\n              }catch(err){}\n              \n              this.setState({\n                schema: schemaObj, // jsSchema\n                mainTab\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching languages:', err);\n            }\n          })\n      \n        }\n      \n        @autobind\n        async saveDataUpdates(){\n        \n          console.log('Saving updates');\n      \n          let dataBeforeParse = this.props.editState.fields.data.value;\n      \n          let realData;\n    \n          try {\n            realData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            return false;\n          }\n      \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            data: realData, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n        \n        @autobind\n        fetchParentsOfNodesToLearn(){\n          return new Promise(async (resolve, reject)=>{\n            \n            this.setState({\n              fetchingParents: true\n            })\n            \n            let parentNodes = [];\n            try {\n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'search_internal_datasource:0.0.1:local:2h3ufih8s9h2f',\n                            dataForAction: {\n                              type: 'standard_query_request:0.0.1:local:65723f2khfds',\n                              data: {\n                                matchFunctionNode: {\n                                  // query here!\n                                  // action_pointer:0.0.1:local:238972ncr\n                                  type: 'code_miniverse:0.0.1:local:2782fh8823s23',\n                                  data: {\n                                    code: `(()=>{\n                                      // Action \n                                      // - childNode common_type:0.0.1:local:298fh29h2323f == \"action\" \n                                      \n                                      let inputNode = INPUT.data.inputNode;\n                                      \n                                      if(inputNode.nodeId){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.type != \"parent_of_nodes_to_learn:0.0.1:local:2839fh29\"){\n                                        return false;\n                                      }\n                                      \n                                      if(inputNode.data.environment != \"browser\"){\n                                        return false;\n                                      }\n                                      \n                                      return inputNode;\n                                      \n                                    })()`\n                                  }\n                                },\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              parentNodes = response.data.actionResponses[0].data;\n              \n              console.log('parentNodes updated');\n            }catch(err){\n              console.error('Failed updating parentNodes');\n            }\n            \n            this.setState({\n              parentNodes,\n              fetchingParents: false\n            })\n            \n            resolve(parentNodes);\n            \n          });\n        }\n      \n        @autobind\n        async handleUpdateType(){\n        \n          let type = WINDOW.prompt('Type:',this.props.node.type);\n          if(!type){\n            return false;\n          }\n    \n          type = type.trim();\n\n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            type, // type should be correct! ,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        async handleUpdateParent(){\n          \n          console.log('Node:', this.props.node);\n          \n          let nodeId = WINDOW.prompt('Parent Node ID:',this.props.node.nodeId || '');\n          if(!nodeId){\n            return false;\n          }\n    \n          nodeId = nodeId.trim();\n          \n          if(!nodeId.length){\n            nodeId = null;\n          }\n  \n          // create it on the server \n          let nodeToSave = {\n            _id: this.props.node._id,\n            nodeId,\n            updatedAt: (new Date()).getTime()\n            // schemaObj: JSON.parse(outputVal)\n          }\n          \n          this.makeSaveRequest(nodeToSave);\n        \n        }\n      \n        @autobind\n        handleDuplicate(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let doParent;\n            if(node.nodeId){\n              doParent = WINDOW.prompt('Keep parent? (y/n)','y');\n              if(!doParent){\n                return false;\n              }\n            }\n      \n            let doChildren;\n            if(node.nodes && node.nodes.length){\n              doChildren = WINDOW.prompt('Keep child nodes? (y/n)','y');\n              if(!doChildren){\n                return false;\n              }\n            }\n      \n            console.log('NODE:', node);\n      \n            // // Send in a Node that will be learned by the AI \n            // {\n            //   type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n            //   data: {\n            //     // what to import! \n            //     _id: \"testingid2\",\n            //     nodeId: null,\n            //     type: \"emoji:0.0.1:local:2f9jsd98fj293fsdf\",\n            //     // expected/allowed schemas for return \n            //     data: {\n            //       emoji: \"joy\"\n            //     }\n            //   }\n            // },\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n      \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: (doParent === 'y') ? node.nodeId:null,\n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            if(doChildren){\n              await saveChildNodes(savedNode.data._id, node.nodes);\n            }\n            \n            console.log('Done duplicating');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n      \n        @autobind\n        handleAddChild(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = this.props.node;\n      \n            let type;\n            type = WINDOW.prompt('Type?','');\n            if(!type){\n              return false;\n            }\n            \n            type = type.trim();\n            \n            // todo: get and validate the type's schema. use schema for default data\n            \n            this.setState({\n              saving: true\n            });\n      \n            let newNode = {\n              nodeId: node._id,\n              type: type,\n              data: null\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true});\n            \n            console.log('Saved Node', savedNode);\n          \n            console.log('Done creating new');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.setState({\n              saving: false\n            });\n      \n            // window.location = '/node/' + savedNode._id;\n      \n          });\n      \n        }\n        \n        @autobind\n        handleAddChildPaste(){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            let nodeText = this.state.pasteText; //WINDOW.prompt('Node JSON String','');\n            if(!nodeText){\n              return false;\n            }\n            \n            let node = JSON.parse(nodeText);\n            console.log('Node input:', node);\n            \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Save node ('+node.type+') and children for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n            \n            // iterate\n            // - save this one, then start saving down tree\n            let newNode = {\n              nodeId: this.props.node._id, \n              type: node.type,\n              data: node.data,\n            }\n      \n            console.log('newNode:', newNode);\n      \n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('Saved Node');\n          \n            const saveChildNodes = (nodeId, childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n      \n                console.log('Saving children');\n                \n                for(let tmpNode of childNodes){\n                  let newChildNode = {\n                    nodeId,\n                    type: tmpNode.type,\n                    data: tmpNode.data,\n                  }\n                  let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n      \n                    await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n      \n                  }\n                }\n                resolve();\n              });\n            }\n      \n            await saveChildNodes(savedNode.data._id, node.nodes);\n            \n            console.log('Done Adding via Paste');\n      \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n          });\n        }\n      \n        @autobind\n        handleExportNode(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(node);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildren(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Export as JSON (copied to clipboard)?');\n            if(!confirm){\n              return false;\n            }\n            \n            let nodes = node.nodes || [];\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            let j = JSON.stringify(nodes);\n            WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            universe.copy(j);\n            \n          });\n      \n        }\n      \n        @autobind\n        handleExportChildrenToLocalStorage(storageKey){\n          \n          return new Promise(async (resolve,reject)=>{\n      \n            // let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            let confirm;\n            confirm = WINDOW.confirm('Will overwrite: ' + storageKey);\n            if(!confirm){\n              return false;\n            }\n            \n            // Find the node from the storageKey! \n            // - must be stored in a parent_of_nodes_to_learn tree \n            \n            // parent_of_nodes_to_learn:0.0.1:local:2839fh29\n          \n            let node = universe.lodash.find(this.state.parentNodes,n=>{\n              return n.data.learn == storageKey;\n            });\n            console.log('NODE:', node, this.state.parentNodes);\n            let nodes = JSON.parse(JSON.stringify(node.nodes || []));\n            nodes = nodes.map(node=>{\n              delete node.nodeId;\n              return node;\n            })\n            \n            console.log('NODES:', nodes);\n            \n            // JSON-ify, export to be imported into browser/etc.\n            // - for the \"learn basics\" Nodes (default ExternalIdentity, capabilities, etc.) \n            // let j = JSON.stringify(nodes);\n            // WINDOW.tmpJ = j;\n            // console.log('JSON-ified:', j);\n            // WINDOW.prompt('JSON',WINDOW.btoa(j));\n            // universe.copy(j);\n            \n            let uiApps = await localforage.getItem('possible-ui-apps');\n            uiApps = uiApps || {};\n            \n            uiApps[storageKey] = nodes;\n            \n                  \n            let updatedApps = await localforage.setItem('possible-ui-apps', uiApps);\n            \n            \n            \n          });\n      \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main'\n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n      \n        @autobind\n        handleKeyDown(e){\n          if(this.aceRef && this.aceRef.editor){\n            this.aceRef.editor.commands.addCommand({\n              name: 'save',\n              bindKey: {\n                win: 'Ctrl-S',\n                mac: 'Command-S'\n              },\n              exec: (env, args, request)=>{\n                this.saveDataUpdates();\n              }\n            });\n            \n            // overwrite Cmd-D to same as sublime \n            this.aceRef.editor.commands.addCommand({\n              name: 'selectMoreAfter2',\n              bindKey: {\n                win: 'Ctrl-D',\n                mac: 'Command-D'\n              },\n              exec: (env, args, request)=>{\n                // selectMoreAfter\n                // console.log('selectMoreAfter!');\n                this.aceRef.editor.execCommand(\"selectMoreAfter\")\n              }\n            });\n          }\n      \n        }\n        \n        @autobind\n        handleChangeMainTab(tabName){\n          \n          // using \"__ALL__\" as the \"main\" holder\n          // - otherwise assume we are editing a field \n          \n          this.setState({\n            mainTab: tabName,\n            aceHeight: 0\n          },()=>{\n            this.resizeAce();\n          })\n        }\n        \n        \n        render(){\n          \n          // add \"fields\" to mainTab for the selected Node \n          // - also should show \"unused\" fields from schema? \n          \n          let node = this.props.node;\n      \n          let { value, parentValue } = this.props.editState.fields.data; // value is always a String!!!! (might not be Parseable tho!) \n    \n          let mainTabs = [\n            ['__ALL__','All']\n          ]\n      \n          let dataBeforeParse = value;\n          let isValidJSON = true;\n          let parsedData;\n          try {\n            parsedData = JSON.parse(dataBeforeParse);\n          }catch(err){\n            isValidJSON = false;\n          }\n      \n      \n          // validates?\n          let data = value;\n          let isValidDataForSchema = false;\n          let schemaValidationErrors = '';\n      \n      \n          if(this.state.schema){\n      \n            if(this.state.schema.type == 'object'){\n      \n              if(typeof data == 'string'){\n                try {\n                  data = JSON.parse(data);\n                }catch(err){\n                  // return false;\n                  data = null;\n                }\n              } else {\n                // leave as-is (assume String/Number) \n              }\n      \n            } else {\n              // use raw value\n              // data = dataBeforeParse;\n            }\n      \n            try {\n              let validate = universe.jsSchema.fromJSON(this.state.schema);\n              let validates = validate(data);\n              // console.log('validates:', validates);\n              if(validates){ \n                isValidDataForSchema = true;\n              } else {\n                schemaValidationErrors = validate.errors(data);\n              }\n              // console.log('schemaValidationErrors',schemaValidationErrors);\n            }catch(err){\n              console.error('jsSchema err:', err);\n            }\n            \n            // tabs\n            if(this.state.schema.type == 'object'\n              && isValidJSON){\n              try {\n                let objTabs = Object.keys(parsedData).map(d=>{return [d,d]});\n                mainTabs = mainTabs.concat(objTabs);\n              }catch(err){\n                \n              }\n            }\n            \n          }\n          \n          let outputVal;\n          if(this.state.mainTab != '__ALL__'){\n            // this.props.editState.fields.data.value ? this.props.editState.fields.data.value.code:''\n            try {\n              // console.log('dATAVAL',this.props.editState.fields.data.value);\n              value = JSON.parse(this.props.editState.fields.data.value)[this.state.mainTab];\n            }catch(err){\n              console.error('failed parsing value for field.', err);\n            }\n          }\n          \n          return (\n            <div className=\"fill-height-or-more\">\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level-NOTANYMORE\">\n                    <div className=\"level-right-NOTANYMORE pull-right\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small is-danger\" onClick={this.handleDelete}>\n                              Delete\n                            </a>\n                          </p>\n                        </div>\n                      </div>\n                    </div>\n                    <div className=\"level-left-NOTANYMORE\">\n                      <div className=\"level-item-NOTANYMORE\">\n                        <h3 className=\"title is-4\">\n                          {node.type}\n                        </h3>\n                        <h3 className=\"subtitle is-6\">\n                          {node._id}\n                        </h3>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div style={{flex:'0 1 auto'}}>\n                <div style={{padding: '4px'}}>\n                  <div className=\"level\">\n                    <div className=\"level-left\">\n                      <div className=\"level-item\">\n                        <div className=\"field is-grouped\">\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateType}>\n                              Change Type\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleUpdateParent}>\n                              Change Parent\n                            </a>\n                          </p>\n                          <p className=\"control\">\n                            <a className=\"button is-small\" onClick={this.handleDuplicate}>\n                              Duplicate\n                            </a>\n                          </p>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.addingChild ? ' is-loading':'')}>\n                                <span>Add Child</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleAddChild}>\n                                  Blank\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={e=>this.setState({pastable: !this.state.pastable})}>\n                                  Paste JSON\n                                </a>\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          <div className=\"control dropdown is-hoverable\">\n                            <div className=\"dropdown-trigger\">\n                                                      \n                              <button className={\"button is-small\" + (this.state.fetchingParents ? ' is-loading':'')}>\n                                <span>Export</span>\n                                <span className=\"icon is-small\">\n                                  <i className=\"fa fa-angle-down\"></i>\n                                </span>\n                              </button>\n                            </div>\n                            <div className=\"dropdown-menu\">\n                              <div className=\"dropdown-content\">\n                              \n                                <a className=\"dropdown-item\" onClick={this.handleExportNode}>\n                                  Node to Clipboard\n                                </a>\n                                \n                                <a className=\"dropdown-item\" onClick={this.handleExportChildren}>\n                                  Children to ClipBoard\n                                </a>\n                                \n                                {\n                                  (this.state.parentNodes || []).map(parentNode=>{\n                                    return (\n                                      <a key={parentNode._id} className=\"dropdown-item\" onClick={e=>this.handleExportChildrenToLocalStorage(parentNode.data.learn)}>\n                                        To LocalStorage: <strong>{parentNode.data ? parentNode.data.learn:'missing'}</strong>\n                                      </a>\n                                    )\n                                  })\n                                }\n                                \n                              </div>\n                            </div>\n                          </div>\n                          \n                          \n                          \n                          {\n                            !this.state.saving ? '':\n                            <p className=\"control\">\n                              <a className={\"button is-small is-white is-loading\"}>\n                                &nbsp;\n                              </a>\n                              <a className={\"button is-small is-white\"}>\n                                Saving...\n                              </a>\n                            </p>\n                          }\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              {\n                !this.state.pastable ? '':\n                <div>\n                  <textarea className=\"textarea\" value={this.state.pasteText} onChange={e=>this.setState({pasteText:e.target.value})} />\n                  <button className=\"button\" onClick={this.handleAddChildPaste}>Save</button>\n                </div>\n              }\n              \n              <div style={{flex:'0 1 auto'}}>\n                <div className=\"tabs\">\n                  <ul>\n                    {\n                      mainTabs.map(tab=>(\n                        <li \n                          key={tab[0]}\n                          className={this.state.mainTab == tab[0] ? \"is-active\":''}\n                          onClick={e=>this.handleChangeMainTab(tab[0])}\n                        ><a>{tab[1]}</a></li>\n                      ))\n                    }\n                  </ul>\n                </div>\n              </div>\n              \n              <div \n                className=\"\" \n                style={{flex:'1 1 auto'}}\n                ref={r=>this.parentRef=r}\n                >\n                <div \n                  style={{height: this.state.aceHeight+'px', position: 'relative'}} \n                  >\n                        \n                  <AceEditor\n                    ref={r=>this.aceRef=r}\n                    mode=\"jsx\"\n                    theme=\"monokai\"\n                    value={value}\n                    onChange={v=>{\n                      if(this.state.mainTab == '__ALL__'){\n                        // if(this.state.schema.type == 'object'){\n                        //   this.props.setEditState('data', v)\n                        // } else {\n                        //   // raw\n                          this.props.setEditState('data', v)\n                        // }\n                      } else {\n                        let newObj = {};\n                        newObj[this.state.mainTab] = v;\n                        // console.log('onchangedata:', data, this.props.editState.fields.data);\n                        let newData = Object.assign({},data,newObj)\n                        this.props.setEditState('data', JSON.stringify(newData));\n                      }\n                    }}\n                    name=\"UNIQUE_ID_OF_DIV2\"\n                    editorProps={{$blockScrolling: true}}\n                    width=\"100%\"\n                    height=\"100%\"\n                    onLoad={editor=>{\n                      editor.getSession().setUseWrapMode(true);\n                    }}\n                    setOptions={{\n                      enableBasicAutocompletion: true,\n                      enableLiveAutocompletion: true,\n                      showPrintMargin: false,\n                      enableSnippets: true,\n                      behavioursEnabled: false,\n                      showLineNumbers: true,\n                      tabSize: 2\n                    }}\n                  />\n                  \n                </div>\n              </div>\n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      \n      mycomponent = universe.withEditManager(mycomponent,{\n        editProp: 'node',\n        fields: ['type','data'],\n        fieldConvertServerOnceFunc: {\n          data: v=>{\n            return JSON.stringify(v,null,2)\n          }\n        },\n        fieldConvertServerFunc: {\n          // tmpData: v=>{\n          //   if(v){\n      \n          //   }\n          //   return v;\n          // }\n          // data: v=>{\n          //   // jsSchema\n          //   // console.log('NewServerData:', v);\n          //   if(v instanceof String){\n          //     return v;\n          //   }\n          //   return JSON.stringify(v);\n          //   // return JSON.stringify({\n          //   //   data: v // necessary to do this to retain correct types? \n          //   // },null,2)\n          // }\n        },\n        fieldCompareFunc: {\n          // uri: (prev, next)=>{\n          //   console.log('URI compare!:', prev, next);\n          //   return prev === next;\n          // }\n        }\n      });\n\n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  },
  "active": true,
  "createdAt": 1513467073269,
  "updatedAt": 1514959360040
}