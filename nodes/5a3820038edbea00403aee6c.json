{
  "_id": "5a3820038edbea00403aee6c",
  "type": "code:0.0.1:local:32498h32f2",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve, reject)=>{\n    try {\n      \n      // Expecting INPUT = capability_input_node:0.0.1:local:29f8239a13h9\n      // - capabilityNode: Object,\n      // - externalInputNode: Object,\n      \n      // Load the \"UserCommand\" capability\n      \n      let cmdInputNode = INPUT.data.externalInputNode;\n      \n      if(cmdInputNode.type != 'standard_capability_action:0.0.1:local:298j291bs'){\n        console.log('Unexpected input schema');\n        return reject();\n      }\n      \n      let inputAction = cmdInputNode.data.action;\n      let inputOpts = cmdInputNode.data.options;\n      \n      \n      \n      // used in matching patterns \n      const blockHasPattern = (blocks, patterns)=>{\n      \tif(!universe.lodash.isArray(patterns)){\n      \t\tpatterns = [patterns];\n      \t}\n      \n      \tlet has = false;\n      \n      \t// console.log('blockArrayCheck', blocks);\n      \t// console.log('patterns', patterns);\n      \n      \tblocks.forEach(blockPattern=>{\n      \t\tpatterns.forEach(pattern=>{\n      \t\t\tif(blockPattern[0] == pattern){\n      \t\t\t\thas = true;\n      \t\t\t}\n      \t\t});\n      \t});\n      \n      \treturn has;\n      };\n      \n      \n\n      switch(inputAction){\n        case 'parseTextWithNodes':\n          console.log('UserCommand.parseTextWithNodes');\n          \n          // inputOpts.text\n          // inputOpts.contextNodes \n          \n          // output: possible \"user_command_match_with_action:0.0.1:local:0001930jf3\" matches \n          // - user/Second who receives output can decide to run the actionCodeNode via run_action_sequence \n          let text = inputOpts.text;\n          let parsedBlockArray;\n          \n          // fetch all the possible local previous user commands (todo: store elsewhere, global?) \n          // user_command_match_with_action:0.0.1:local:0001930jf3\n          \n          let LocalUserCommandNodes = await universe.searchMemory({\n            filter: {\n              sqlFilter: {\n                type: 'user_command_match_with_action:0.0.1:local:0001930jf3',\n              }\n            }\n          });\n          \n          let keyphrases = {};\n          let typeCombos = {};\n          LocalUserCommandNodes.forEach(luc=>{\n            luc.data.command.wordNodes.forEach(wn=>{\n              if(!keyphrases[wn.data]){\n                keyphrases[wn.data] = {};\n              }\n              if(!keyphrases[wn.data][wn.type]){\n                keyphrases[wn.data][wn.type] = 0;\n              }\n              keyphrases[wn.data][wn.type]++;\n            })\n            \n            let typeStr = luc.data.command.wordNodes.map(wn=>wn.type).join(',');\n            if(!typeCombos[typeStr]){\n              typeCombos[typeStr] = [];\n            }\n            typeCombos[typeStr].push(luc);\n          })\n          \n          // user_command_match_with_action:0.0.1:local:0001930jf3 data = {\n          //   preParseCodeNode: { data: {key:String,code:String}\n          //   },\n          //   preParseCodeNode: {},\n          //   command: {\n          //     text: String,\n          //     wordArray: [{\n          //       text: String, // Word\n          //       nodeId: id // for node from wordNodes! \n          //     }],\n          //     wordNodes: [{\n          //       _id: id,\n          //       type: 'string:...',\n          //       data: String? \n          //     }],\n          //   },\n          // }\n            \n            \n          \n          // convert text to phrases and words (ngrams) \n          // - 6-word-max phrases \n          // - parse into blockArray of types \n          // - merge certain types together (strings) \n          \n          let parseRunCount = 0;\n          \n          // parseTextIntoBoxes returns an Array of types for matching against existing \n          // - returns [ [\"comma_separated,types_for,text_it_matches\", [\"text\",\"for each\",\"type\"]] ]\n          // - this should be SKIPPABLE as well! (allow the user to say what it is, then run the matching) \n          const parseTextIntoBoxes = (dataToParse) => {\n            return new Promise(async (resolve,reject)=>{\n              try {\n                \n                // dataToParse.text = String \n                parseRunCount++;\n                universe.console.log('parseTextIntoBoxes1',parseRunCount);\n              \n                let blockArray = []; // this will hold the output to be resolved! \n                \n                // Get ngrams for phrase \n              \tlet ngrams = [];\n              \tlet words = dataToParse.text.split(' ');\n              \n                for(let gramLength = universe.lodash.min([words.length,5]); gramLength>0; gramLength--){\n                \tlet loopKiller = 0;\n                \tlet localIndex = 0; //startIndex;\n                \tif(localIndex + gramLength > words.length){\n                \t\tcontinue;\n                \t}\n                \twhile(true && loopKiller < 100){\n                \t\tloopKiller++;\n                \t\tlet phrase = words.slice(localIndex,gramLength + localIndex).join(' ');\n                \n                \t\tngrams.push({\n                \t\t\tindex: localIndex,\n                \t\t\tlen: gramLength,\n                \t\t\tphrase: phrase,\n                \t\t\tboxArray: []\n                \t\t});\n                \n                \t\tlocalIndex++;\n                \t\tif(localIndex + gramLength > words.length){\n                \t\t\tbreak;\n                \t\t}\n                \t}\n                }\n              \t\n              \n                // For each phrase, get all the possible Types it could be \n                // - will always match a few types (string, dynamic_string) \n                \n                // Build boxArray of all types: []\n                \n                        \n              \t// Run recursion against the component parts\n              \t// - but NOT the whole matching string (would be infinite) \n              \tlet wholePhrase = ngrams.shift();\n              \tfor(let insidePhrase of ngrams){\n              \t  let tmpBlockArray = await parseTextIntoBoxes({\n              \t    text: insidePhrase.phrase,\n              \t    contextNodes: dataToParse.contextNodes\n              \t  });\n              \t  \n              \t\t// boxArrayObj.blockArray = [ ['number,string',['seventy','degrees']], [ 'number,temperature-suffix',['seventy','degrees'] ] ] \n              \t\t\t\n              \t\tinsidePhrase.boxArray = tmpBlockArray;\n              \t}\n              \t\n                \n              \t// Build blockArray (declared way above) \n              \t// - before THEN checking (function after this) to see if this combination creates another single-type (likely for smaller ones, unlikely for longer strings [unless they contain a search query?])\n\n                // Join ngrams together for evaluation (I think)?? \n    \t\t\t\t\t\tconst nti = (typeStrArr, textPhraseArr, nextToInclude)=>{\n    \t\t\t\t\t\t\tnextToInclude.forEach(insidePhrase=>{\n    \t\t\t\t\t\t\t\t\n    \t\t\t\t\t\t\t\tinsidePhrase.boxArray.forEach(ba=>{\n    \n    \t\t\t\t\t\t\t\t\tlet tmpTypeStr = typeStrArr.concat([]),\n    \t\t\t\t\t\t\t\t\t\ttmpTextArr = textPhraseArr.concat([]);\n    \n    \t\t\t\t\t\t\t\t\ttmpTypeStr.push(ba[0]);\n    \t\t\t\t\t\t\t\t\ttmpTextArr.push(ba[1]);\n    \n    \t\t\t\t\t\t\t\t\tif((insidePhrase.index + insidePhrase.len) == words.length){ // no_more_to_include\n    \t\t\t\t\t\t\t\t\t\t// if(tmpTypeStr.join(',') == 'string,temperature'){\n    \t\t\t\t\t\t\t\t\t\t// \t// console.log('ST', universe.lodash.flatten(tmpTextArr), insidePhrase);\n    \t\t\t\t\t\t\t\t\t\t// }\n    \t\t\t\t\t\t\t\t\t\tblockArray.push([ tmpTypeStr.join(','), universe.lodash.flatten(tmpTextArr) ]);\n    \t\t\t\t\t\t\t\t\t} else {\n    \t\t\t\t\t\t\t\t\t\t// run again\n    \t\t\t\t\t\t\t\t\t\tlet nextToInclude = universe.lodash.filter(ngrams,inside=>{\n    \t\t\t\t\t\t\t\t\t\t\treturn inside.index == (insidePhrase.index + insidePhrase.len);\n    \t\t\t\t\t\t\t\t\t\t});\n    \t\t\t\t\t\t\t\t\t\tnti(tmpTypeStr, tmpTextArr, nextToInclude); \n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t});\n    \t\t\t\t\t\t\t});\n    \t\t\t\t\t\t}\n    \n    \t\t\t\t\t\tlet firstToInclude = universe.lodash.filter(ngrams,inside=>{\n    \t\t\t\t\t\t\treturn inside.index == 0;\n    \t\t\t\t\t\t});\n                \n    \t\t\t\t\t\tnti([],[], firstToInclude);\n    \t\t\t\t\t\t\n    \t\t\t\t\t\t\n\t              // Check the current value/chain (single value, or array completely built!) \n\t\n    \t\t\t\t\t\t// Find matches for children \n    \t\t\t\t\t\t// - blockArray type matches for previously-said things \n    \t\t\t\t\t\tlet singleItemBlockArray = [];\n                \t\t\t\t\t\t\n            \t\t// if(text.split(' ').length == 1 && partsOfSpeech && partsOfSpeech.length == 1){\n            \t\t// \t// singleItemBlockArray.push('pos-' + partsOfSpeech[0].toLowerCase());\n            \t\t// }\n            \n            \t\tlet textSplit = dataToParse.text.split(' ');\n            \n            \t\t// combine two or more things of the same \"type\" into a single type\n            \t\t// - string,string = string\n            \t\t// - temperature,temperature = temperature\n            \t\t// - etc...\n            \t\tif(blockArray.length && textSplit > 1){\n            \t\t\t// universe.lodash.range(blockArray.length - 1).forEach(function(i){\n            \n            \t\t\t// \tif(blockHasPattern(blockArray, [])){\n            \t\t\t// \t\tsingleItemBlockArray.push('string');\n            \t\t\t// \t}\n            \t\t\t// });\n            \n            \t\t\t// combine/collapse strings\n            \t\t\t// - todo: figure out if a string is even relevant, based on previous strings we \"know\" about? \n            \t\t\t\n            \t\t\t// todo...add all the possible \"combine\" types here\n            \t\t\tlet combineTypes = [\n            \t\t\t  'phrasematch_useless_string:0.0.1:local:882398892121',\n            \t\t\t  'phrasematch_static_string:0.0.1:local:2930fj89sd',\n            \t\t\t  'phrasematch_connection_words:0.0.1:local:0j90jfsdnfksf'\n            \t\t\t ]; \n            \t\t\tcombineTypes.forEach(ct=>{\n            \t\t\t\tif(blockHasPattern(blockArray, [ universe.lodash.map(universe.lodash.range(textSplit.length),i=>ct).join(',') ])){\n            \t\t\t\t\tsingleItemBlockArray.push(ct);\n            \t\t\t\t}\n            \t\t\t});\n            \t\t\t\n            \t\t}\n                \n                \n                // Run all functions to determine what this might be \n                // - todo...\n                \n                \n            \t\t// // search through keyphrases to see if it matches any existing wordNodes \n            \t\t// keyphrases.forEach(keyphrase=>{\n            \t\t// \tif(keyphrase.text == dataToParse.text){\n            \t\t// \t\t// console.log('Keyphrase matched: ', dataToParse.text);\n            \t\t// \t\tsingleItemBlockArray.push( keyphrase.type ); // could be anything...\n            \t\t// \t}\n            \t\t// });\n            \t\tif(keyphrases[dataToParse.text]){\n            \t\t  // keys are types \n            \t\t  singleItemBlockArray = singleItemBlockArray.concat(Object.keys(keyphrases[dataToParse.text]));\n            \t\t}\n            \n            \t\t// things it usually is \n            \t\t// - static_string\n            \t\t// - connection_words (\n            \t\t// singleItemBlockArray.push('phrasematch_static_string:0.0.1:local:2930fj89sd');\n            \t\tif(textSplit.length > 1){\n            \t\t  singleItemBlockArray.push('phrasematch_connection_words:0.0.1:local:0j90jfsdnfksf');\n            \t\t}\n            \n            \t\t// things it can always be:\n            \t\t// - ignored string\n            \t\tsingleItemBlockArray.push('phrasematch_useless_string:0.0.1:local:882398892121');\n            \t\t\n            \n            \t\tlet added = [];\n            \t\tsingleItemBlockArray.forEach(ba=>{\n            \t\t\tif(added.indexOf(ba) > -1){\n            \t\t\t\t// console.log('skipping');\n            \t\t\t\treturn;\n            \t\t\t}\n            \t\t\tadded.push(ba);\n            \t\t\tblockArray.push([ba,[dataToParse.text]]);\n            \t\t});\n            \n            \t\t// console.log('Result blockArray', blockArray);\n            \t\t// console.log('newBlockArray');\n            \t\t// console.log(blockArray);\n            \n            \t\t// setResult({\n            \t\t// \tblockArray: blockArray\n            \t\t// });\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tresolve(blockArray);\n              \n              }catch(err){\n                console.error('parseTextIntoBoxes err:', err);\n              }\n            });\n          }\n          \n          parsedBlockArray = await parseTextIntoBoxes({\n            text: inputOpts.text,\n            contextNodes: inputOpts.contextNodes\n          }); \n          \n          console.log('parseRunCount:', parseRunCount);\n          \n          // - each Phrase-combo, find matches for each in phrase \n          //   - text maybe be a match of many types of results, check for \"possible\" ones that are used, etc.\n          // - build array of fullPossible type matches \n          // - order according to weighted ML algorithm (success/correct results come from user input) \n          //   - give a slight weight to non-string (no-match) things \n          \n          \n          // Get LocalUserCommandNodes that match typeCombos \n          let matches = [];\n          for(let blockArr of parsedBlockArray){\n            let typeComboList = typeCombos[blockArr[0]];\n            if(typeComboList){\n              for(let phraseMatch of typeComboList){\n                \n                let matchTypes = blockArr[0].split(',');\n                // types match (string, string, boolean) \n                // - get \"values\" for each match in that type \n                // - verifies that the types (and data) are valid \n                //   - (static_string type could match, with different text obviously not matching) \n                let ok = true; // default to matching all types (except static_strings) \n                for(let mtIdx in matchTypes){\n                  // console.log('matchTypes:', matchTypes, mtIdx, phraseMatch);\n                  let mt = matchTypes[mtIdx];\n                  switch(mt){\n                    case 'phrasematch_static_string:0.0.1:local:2930fj89sd':\n                      // must be exact text match!\n                      // - todo: case insensitive (.toLowerCase() ? )\n                      if(blockArr[1][mtIdx] != phraseMatch.data.command.wordNodes[mtIdx].data){\n                        ok = false;\n                      }\n                      break;\n                      \n                    default:\n                      break;\n                  }\n                }\n                \n                if(ok){\n                  matches.push({\n                    _id: universe.uuidv4(), // create new \n                    type: 'standard_user_command_match:...',\n                    data: {\n                      previous: phraseMatch, // for using preParseCodeNode, etc. \n                      now: blockArr  // for inserting our values\n                    }\n                  });\n                }\n                \n              }\n            }\n          }\n          \n          console.log('Returning parse_result');\n          \n          // find similar that didnt typematch using distance algorithm \n          let targetMatches = LocalUserCommandNodes.map(n=>n.data.command.text);\n          let similar = [];\n          try {\n            similar = universe.stringSimilarity.findBestMatch(text, targetMatches).ratings;\n          }catch(err){\n            // fails if bad targetMatches \n          }\n          \n          // ML Todos: \n          // ML for \"what is this phrase a type of?\" \n          // ML for \"what is the order/bestmatch of the results to existing Tasks/Actions?\" \n          \n          // Recommended/Default view vs. \"just a list\" type of view \n          \n          return resolve({\n            type: 'parse_result:...',\n            data: {\n              matches,\n              similar,\n              parsedBlockArray\n            }\n          });\n          \n          //   parse:true,\n          //   inputOpts,\n          //   parsedBlockArray,\n          //   parseRunCount\n          // });\n          \n        default:\n          return reject({});\n          \n      }\n        \n    }catch(err){\n      console.error('err2:', err);\n      resolve({ERROR: true, err: err.toString()});\n    }\n    \n    \n  })\n})()",
    "note": "Capability: UserCommand",
    "key": "508e6e42-51ec-44d6-aa9b-10a912da2ed8"
  },
  "active": true,
  "createdAt": 1513627651435,
  "updatedAt": 1513899436685
}