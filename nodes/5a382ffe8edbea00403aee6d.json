{
  "_id": "5a382ffe8edbea00403aee6d",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      \n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      const Select = universe.ReactSelect;\n      const Link = universe.ReactRouterDomLink;\n      \n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          \n          this.state = {\n            editingNodeId: null, // will be ID of node that is being edited \n            currentSelectedPreParseCodeKey: null, \n            currentSelectedActionCodeKey: null, \n            text: this.props.node.data.text,\n            words: [],\n            wordArray: [],\n            wordNodes: [],\n            currentSelectedType: null,\n            allTypes: [],\n            allUserCommandCodeNodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n          console.log('Mounted EditingPhraseComponent');\n          this.parseNewText();\n          this.fetchAllTypes();\n          this.fetchCodeNodes();\n        }\n        \n        componentWillReceiveProps(nextProps){\n          \n          // console.log('Mounted EditingPhraseComponent');\n          // setTimeout(()=>{\n          //   this.update\n          // },1)\n          \n        }\n        \n        @autobind\n        fetchAllTypes(){\n          // fetch all types from Language server \n          // - used for \"phrasematch_\" \n          \n          let data = JSON.parse('{\"operationName\":null,\"variables\":{},\"query\":\"query {  languageMany {    _id    slug    title    schemaCode    schemaObj    createdAt    updatedAt    __typename  }}\"}');\n          data = JSON.stringify(data);\n          universe.$.ajax({\n            url: 'http://localhost:7011/graphql',\n            method: 'post',\n            contentType: 'application/json',\n            data: data,\n            success: languageResult=>{\n              // console.log('Languages', languageResult);\n              if(!languageResult.data.languageMany){\n                console.error('Missing language types!');\n                return;\n              }\n              console.log('possible types:', languageResult);\n              this.setState({\n                allTypes: languageResult.data.languageMany\n              })\n            },\n            error: err=>{\n              console.error('Failed fetching possible types:', err);\n            }\n          })\n        \n        }\n        \n        @autobind\n        async fetchCodeNodes(){\n        \n          let response = await universe.loadAndRunCapability('Teacher',{},{\n            type: 'standard_capability_action:0.0.1:local:298j291bs',\n            data: {\n              action: 'fetchCodeForUserCommands',\n              options: {}\n            }\n          });\n          \n          console.log('REMOTE code nodes:',response);\n          this.setState({\n            allUserCommandCodeNodes: response.data\n          })\n          \n        }\n        \n        @autobind\n        parseNewText(){\n          let text = this.state.text;\n          \n          // (ignoring special characters )\n          \n          \n          // default setup \n          // - blank! \n          \n          let words = universe.lodash.compact(text.split(' '));\n          let wordArray = words.map(text=>{\n            return {\n              text,\n              // isNode: false\n              // nodeId...\n            }\n          });\n          \n          \n          this.setState({\n            words,\n            wordNodes: [],\n            wordArray,\n            selectedArr: null // [startIdx, endIdx]\n          })\n          \n          \n        }\n        \n        @autobind\n        async handleClickWord(word, idx){\n          \n          // Does word have a node? \n          // - yes: select all the words in node, start editing Node  \n          // - no: if editing, add nodeId to word. if not editing, start a new Node type \n          // Are we currently editing a phrase (don't allow a jump 'out'?) \n          try {\n              \n            let selectedArr = this.state.selectedArr;\n            let editingNodeId = this.state.editingNodeId; \n            let wordArray = this.state.wordArray;\n            let wordFromArr = wordArray[idx];\n            let wordNodes = this.state.wordNodes;\n            console.log('wordFromArr:',wordFromArr, wordArray);\n            console.log('selectedArr:',selectedArr);\n            let thisWordNodeId = wordFromArr.nodeId;\n            let removedWordNodes;\n            if(thisWordNodeId){\n              // has node \n              if(editingNodeId){\n                // already editing \n                // - only remove if mine, can't \"overwrite\" another \n                if(thisWordNodeId != editingNodeId){\n                  console.error('cannot \"overwrite\"');\n                  return false;\n                }\n                \n                // removing (if on an end)\n                if(idx != selectedArr[0] &&\n                   idx != selectedArr[1]){\n                  console.error('must be on either end');\n                  return false;\n                }\n                \n                delete wordArray[idx].nodeId;\n                \n                // if last being removed, remove the Node too \n                if((selectedArr[1] - selectedArr[0]) === 0){\n                  removedWordNodes = universe.lodash.remove(wordNodes,{_id:editingNodeId}); // changes by reference\n                  editingNodeId = null;\n                  selectedArr = null;\n                } else {\n                  // have some left\n                  if(idx == selectedArr[0]){\n                    selectedArr[0] = idx+1;\n                  } else {\n                    selectedArr[1] = idx-1;\n                  }\n                  // modify wordNodes by reference \n                  let tmpWordNode1 = universe.lodash.find(wordNodes,{_id:editingNodeId});\n                  tmpWordNode1.data = wordArray.map(w=>w.text).slice(selectedArr[0],selectedArr[1]+1).join(' ');\n                }\n                \n                console.log('new wordNodes:', wordNodes, editingNodeId);\n                console.log('removedWordNodes',removedWordNodes, editingNodeId);\n                \n                this.setState({\n                  editingNodeId,\n                  // editingNodeId: tmpWordNode, // \"data\" updated \n                  wordNodes,\n                  wordArray,\n                  selectedArr\n                })\n                \n                \n              } else {\n                // not already editing, start editing this phrase\n                // - select the whole thing \n                \n                // get reference to wordNode (for updating data)\n                let tmpWordNode = universe.lodash.find(wordNodes,{_id:thisWordNodeId});\n                // universe.lodash.find(wordNodes, {_id:thisWordNodeId});\n                // tmpWordNode.data = wordArray.map(w=>w.text).slice(selectedArr[0],selectedArr[1]).join(' ');\n                // wordArray[idx].nodeId = tmpWordNode._id;\n                // console.log('new wordNodes:', wordNodes, tmpWordNode);\n                this.setState({\n                  // editingNodeId: tmpWordNode, // \"data\" updated \n                  // wordNodes,\n                  // wordArray,\n                  selectedArr: [\n                    universe.lodash.findIndex(wordArray,{nodeId:tmpWordNode._id}), \n                    universe.lodash.findLastIndex(wordArray,{nodeId:tmpWordNode._id})\n                  ],\n                  editingNodeId: tmpWordNode._id,\n                  currentSelectedType: tmpWordNode.type\n                })\n                return;\n              }\n              \n            } else{\n              // no node on selected \n              if(editingNodeId){\n                // already editing, trying to add this one to the nodeId list \n                // - see if can add (not breaking any chain) \n                //   - add \"in-between\" words \n                // - can only remove things by clicking?\n                \n                console.log('trying to add text to an existing Edit');\n                \n                // must be immediately before or after\n                if(idx != (selectedArr[0]-1) && \n                  idx != (selectedArr[1]+1)){\n                  console.log('Not an immediate sibling, not doing \"in-between\" for now');\n                  return false;\n                }\n                \n                if(idx < selectedArr[0]){\n                  selectedArr[0] = idx;\n                } else {\n                  selectedArr[1] = idx;\n                }\n                \n                // add to node array \n                // - update wordNode with latest phrase \n                console.log('wordNodes:', wordNodes, thisWordNodeId, editingNodeId);\n                \n                // get reference to wordNode (for updating data)\n                let tmpWordNode = universe.lodash.find(wordNodes,{_id:editingNodeId});\n                tmpWordNode.data = wordArray.map(w=>w.text).slice(selectedArr[0],selectedArr[1]+1).join(' ');\n                wordArray[idx].nodeId = tmpWordNode._id;\n                console.log('new wordNodes:', wordNodes, tmpWordNode);\n                this.setState({\n                  // editingNodeId: tmpWordNode, // \"data\" updated \n                  wordNodes,\n                  wordArray,\n                  selectedArr\n                })\n              \n                return;\n                \n              } else {\n                // not already editing, start a new Node\n                console.log('not already editing, starting a new Node w/ default phrasematch');\n                let newNode = {\n                  _id: universe.uuidv4(),\n                  type: 'phrasematch_static_string:0.0.1:local:2930fj89sd',\n                  data: word.text\n                }\n                let wordArray = this.state.wordArray;\n                wordArray[idx].nodeId = newNode._id;\n                // console.log('new wordArray:', wordArray);\n                // put new node in correct index of array! super important for parsing! \n                // - do NOT just push onto the end \n                let wordNodes = this.state.wordNodes;\n                let positionInWordNodes = -1;\n                let i=0;\n                let last;\n                while(i<=idx){\n                  if(wordArray[idx].nodeId != last){\n                    positionInWordNodes++;\n                  }\n                  last = wordArray[idx].nodeId;\n                  i++;\n                }\n                // console.log('splice:', positionInWordNodes);\n                wordNodes.splice(positionInWordNodes,0,newNode);\n                // console.log('wordNodes:', wordNodes);\n                // wordNodes.push(newNode);\n                \n                this.setState({\n                  wordNodes,\n                  wordArray,\n                  editingNodeId: newNode._id,\n                  currentSelectedType: newNode.type,\n                  selectedArr: [idx,idx]\n                })\n              }\n            }\n          }catch(err){\n            console.error('failed in handleClickWord', err);\n          }\n          \n        }\n        \n        @autobind\n        handleChangeSelectNodeType(opt){\n          // changing the type of the currently-selected node \n          \n          // update node's value in wordNodes \n          // - whichever wordNode is currently beng edited \n          console.log('Change NodeType');\n          \n        \n          let editingNodeId = this.state.editingNodeId; \n          let wordNodes = this.state.wordNodes;\n          let wordArray = this.state.wordArray;\n          let selectedArr = this.state.selectedArr;\n          let tmpWordNode = universe.lodash.find(wordNodes,{_id:editingNodeId});\n          \n          if(!opt){\n            // removing! \n            let removedWordNodes = universe.lodash.remove(wordNodes,{_id:editingNodeId}); // changes by reference\n            editingNodeId = null;\n            \n            for(let i = selectedArr[0];i<=selectedArr[1];i++){\n              delete wordArray[i].nodeId;\n            }\n            \n            selectedArr = null;\n                \n            this.setState({\n              editingNodeId,\n              // editingNodeId: tmpWordNode, // \"data\" updated \n              wordNodes,\n              wordArray,\n              selectedArr\n            });\n            return false;\n          }\n          \n          tmpWordNode.type = opt.value;\n          // let currentWordNode = \n          \n          this.setState({ \n            wordNodes,\n            currentSelectedType: opt.value \n          });\n          // console.log(`Selected: ${selectedOption.label}`);\n        }\n        \n        @autobind\n        handleChangeSelectPreParseCode(opt){\n          // changing the Node for pre-parsed code \n          \n          console.log('Change PreParseCode Node');\n          \n          this.setState({\n            currentSelectedPreParseCodeKey: opt ? opt.value : null,\n            currentSelectedPreParseCodeNode: opt ? opt.node : null\n          });\n          \n        }\n        \n        @autobind\n        handleChangeSelectActionCode(opt){\n          // changing the Node for pre-parsed code \n          \n          console.log('Change ActionCode Node');\n          \n          this.setState({\n            currentSelectedActionCodeKey: opt ? opt.value : null,\n            currentSelectedActionCodeNode: opt ? opt.node : null\n          });\n          \n        }\n        \n        @autobind\n        handleStopEditingPhrase(){\n          this.setState({\n            editingNodeId: null,\n            selectedArr: null\n          })\n        }\n        \n        @autobind\n        handleCancel(){\n          this.props.onDoneEditing();\n        }\n        \n        @autobind\n        async handleSave(){\n          // Saves/updates the phrase \n          // - stored on Remote as type:user_command_match_with_action\n          // - could also be syndicated elsewhere? (to General Knowledgebase, etc.) \n          \n          // let preParseCodeKey = this.currentSelectedPreParseCodeKey;\n          // let actionCodeKey = this.currentSelectedActionCodeKey;\n          console.log('Trying save', this.state);\n          \n          try {\n            \n            let {\n              currentSelectedPreParseCodeNode,\n              currentSelectedActionCodeNode\n            } = this.state;\n            \n            if(!currentSelectedPreParseCodeNode){\n              console.error('Missing preParse CodeNode');\n              return false;\n            }\n            if(!currentSelectedActionCodeNode){\n              console.error('Missing action CodeNode');\n              return false;\n            }\n            \n            let preParseCodeNode = universe.lodash.clone(currentSelectedPreParseCodeNode);\n            let actionCodeNode = universe.lodash.clone(currentSelectedActionCodeNode);\n            \n            delete preParseCodeNode._id;\n            delete actionCodeNode._id;\n            \n            delete preParseCodeNode.nodeId; // optional \n            delete actionCodeNode.nodeId; // optional \n            \n            let newNode = {\n              type: 'user_command_match_with_action:0.0.1:local:0001930jf3',\n              data: {\n                preParseCodeNode, // runs ONCE before the action (not when actionNodeCode is called directly!)\n                actionCodeNode, // on a prompt, returns all INPUT nodes, and what is missing/needed \n                command: {\n                  text: this.state.text,\n                  wordArray: this.state.wordArray,\n                  wordNodes: this.state.wordNodes\n                }\n              }\n            }\n            \n            console.log('NewNode:', JSON.stringify(newNode,null,2), newNode);\n            \n            // Save new node back to memory \n            // - could also be updating an existing...\n            let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n            \n            console.log('saved node:', savedNode);\n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.onDoneEditing();\n            \n          }catch(err){\n            console.error('Failed save:', err);\n          }\n          \n          \n        }\n      \n        @autobind\n        handleDelete(){\n      \n          return new Promise(async (resolve,reject)=>{\n      \n            let node = JSON.parse(JSON.stringify(this.props.node));\n      \n            // Create this new one, then iterate down the tree of kids \n            // - if this one has a nodeId, ask if we want to keep it? \n            let confirmed = WINDOW.prompt('Delete for sure?','y');\n            if(confirmed != 'y'){\n              return false;\n            }\n      \n            this.setState({\n              saving: true\n            });\n            \n            node.active = false;\n            let deleted = await this.makeSaveRequest({\n              _id: node._id,\n              active: false\n            }, true);\n            \n            const deleteChildNodes = (childNodes) => {\n              return new Promise(async (resolve, reject)=>{\n                \n                for(let tmpNode of childNodes){\n      \n                  // let deletedChildNode = await this.makeDelete(tmpNode);\n                  tmpNode.active = false;\n                  let deletedChildNode = await this.makeSaveRequest({\n                    _id: tmpNode._id,\n                    active: false\n                  }, true);\n      \n                  if(tmpNode.nodes && tmpNode.nodes.length){\n                    await deleteChildNodes(tmpNode.nodes);\n                  }\n                }\n                resolve();\n      \n              });\n            }\n      \n            if(node.nodes){\n              await deleteChildNodes(node.nodes);\n            }\n      \n            this.setState({\n              saving: false\n            });\n        \n            console.log('Done Deleting (and children)');\n          \n            try {\n              universe.EE.emit('nodes-modified', '');\n            }catch(err){\n              console.error(err);\n            }\n            \n            this.props.setState({\n              editingNode: null\n            })\n            // window.location = '/node';\n      \n          });\n      \n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n            } catch(err){\n              console.error('Failed saving new node');\n              \n            }\n            \n            \n          })\n        }\n        \n        render(){\n          \n          let wordArray = this.state.wordArray;\n          \n          let contextFuncs = [\n            // list of functions/code for \"runs/matches when in this Context\" (returns true/false) \n          ];\n          \n          let possibleTypes = this.state.allTypes\n          .filter(t=>{\n            return t.slug.indexOf('phrasematch_') === 0;\n          })\n          .map(t=>{\n            return {\n              label: t.slug.split(':')[0].split('phrasematch_')[1],\n              value: t.slug\n            }\n          });\n          \n          // let possibleCode = this.state.allTypes.filter(t=>{\n          //   return t.slug.indexOf('phrasematch_') === 0;\n          // });\n          let possiblePreParseCode = this.state.allUserCommandCodeNodes\n          .filter(c=>{\n            return c.type == 'preparse_code:0.0.1:local:39fn02n0nfns';\n          })\n          .map(c=>{\n            return {\n              label: c.data.note,\n              value: c.data.key,\n              node: c\n            }\n          })\n          \n          // let possibleCode = this.state.allTypes.filter(t=>{\n          //   return t.slug.indexOf('phrasematch_') === 0;\n          // });\n          let possibleActionCode = this.state.allUserCommandCodeNodes\n          .filter(c=>{\n            return c.type == 'action_code:0.0.1:local:290j92jfn239nma'\n          })\n          .map(c=>{\n            return {\n              label: c.data.note,\n              value: c.data.key,\n              node: c\n            }\n          })\n          \n          // [\n          //   'phrasematch_static_string:0.0.1:local:2930fj89sd', // String\n          //   'phrasematch_connection_words:0.0.1:local:0j90jfsdnfksf' // String\n          // ];\n          \n          return (\n            <div>\n            \n              <hr />\n              \n              <div className=\"field choose-preparse-code\">\n                In Context/Scenario: \n                <Select\n                  placeholder=\"Pre-parse Match Code (determine whether to run, optionally adds Nodes)\"\n                  value={this.state.currentSelectedPreParseCodeKey}\n                  onChange={this.handleChangeSelectPreParseCode}\n                  options={possiblePreParseCode}\n                />\n              \n              </div>\n              \n              <div className=\"field editing-phrase-holder\">\n                And I Say: \n                <div style={{padding:'4px', border:'1px solid #eee'}}>\n                  {\n                    wordArray.map((word,idx)=>{\n                      \n                      // background color? \n                      let backgroundColor = 'white';\n                      let fontWeight = 'normal';\n                      if(word.nodeId){\n                        backgroundColor = universe.Please.make_color({seed: word.nodeId})\n                      }\n                      // selected?\n                      if(this.state.selectedArr){\n                        if(idx >= this.state.selectedArr[0] && idx <= this.state.selectedArr[1]){\n                          fontWeight = 'bold';\n                        }\n                      }\n                      \n                      return (\n                        <div \n                          key={idx}\n                          className=\"word-in-phrase\" \n                          style={{backgroundColor, fontWeight, padding: '4px', cursor:'pointer'}}\n                          onClick={e=>this.handleClickWord(word, idx)}\n                        >\n                          {word.text}\n                        </div>\n                      )\n                    })\n                  }\n                </div>\n              </div>\n              {\n                !this.state.selectedArr ? '':\n                <div className=\"field choose-phrase-type\" style={{paddingLeft:'24px'}}>\n                  <Select\n                    value={this.state.currentSelectedType}\n                    onChange={this.handleChangeSelectNodeType}\n                    options={possibleTypes}\n                  />\n                \n                </div>\n              }\n              {\n                !this.state.editingNodeId ? '':\n                <div className=\"field\" style={{paddingLeft:'24px'}}>\n                  <div className=\"control\">\n                    <button className=\"button\" onClick={this.handleStopEditingPhrase}>\n                      Finish Editing Type\n                    </button>\n                  </div>\n                </div>\n              }\n              \n              <div className=\"field choose-action-code\">\n                Do This Action: \n                <Select\n                  placeholder=\"Action/Task Code\"\n                  value={this.state.currentSelectedActionCodeKey}\n                  onChange={this.handleChangeSelectActionCode}\n                  options={possibleActionCode}\n                />\n              \n              </div>\n              \n              <div className=\"field is-grouped\">\n                <div className=\"control\">\n                  <button className=\"button is-success is-small\" onClick={this.handleSave}>\n                    Save New Action\n                  </button>\n                </div>\n                \n                <div className=\"control\">\n                  <button className=\"button is-small\" onClick={this.handleCancel}>\n                    Cancel\n                  </button>\n                </div>\n              </div>\n              \n              <hr />\n              \n              {/*\n              <hr />\n              <pre><code>{\n                universe.cJSON.stringify(this.state.wordNodes,null,2)\n              }</code></pre>\n              \n              <hr />\n              \n              <pre><code>{\n                universe.cJSON.stringify(this.props.node,null,2)\n              }</code></pre>\n              */}\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "EditingPhraseComponent",
    "key": "acaa41fb-d40a-41c5-8310-e5a671eede43"
  },
  "active": true,
  "createdAt": 1513631742603,
  "updatedAt": 1514408010277
}