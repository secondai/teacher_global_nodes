{
  "_id": "5a3c0a338aeba60026040219",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "key": "e4d1bc49-434f-4b5a-8649-edd82bb2c367",
    "internalId": "UserCommandMatchesComponent",
    "code": "(()=>{\n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      \n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      const Select = universe.ReactSelect;\n      const Link = universe.ReactRouterDomLink;\n      \n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n        \n          this.state = {\n            runningAction: false,\n            allUserCommandCodeNodes: []\n          }\n        }\n        \n        componentDidMount(){\n          \n        }\n        \n        componentWillReceiveProps(nextProps){\n          \n        }\n        \n        @autobind\n        fetchCodeNodes(){\n          return new Promise(async (resolve,reject)=>{\n              \n            // fetch the latest CodeNodes we're using \n            // - so we dont have to keep updating (when in development) \n            let response = await universe.loadAndRunCapability('Teacher',{},{\n              type: 'standard_capability_action:0.0.1:local:298j291bs',\n              data: {\n                action: 'fetchCodeForUserCommands',\n                options: {}\n              }\n            });\n            \n            this.setState({\n              allUserCommandCodeNodes: response.data\n            },resolve)\n            \n          });\n          \n        }\n        \n        @autobind\n        async handleDeleteMatch(){\n          // remove a match \n          \n          // should check if Node is stored locally, or not on a Second I can communicate with? \n          // - want to ignore...add to an Ignore list? \n          let node = this.props.node.data.previous;\n        \n          node.active = false;\n          let deleted = await this.makeSaveRequest({\n            _id: node._id,\n            active: false\n          });\n          \n          this.props.handleRemove();\n        }\n        \n        @autobind\n        makeSaveRequest(nodeToSave, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            this.setState({\n              saving: true\n            })\n            \n            // Make request to save Node on remote \n            try {\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'update_node:0.0.1:local:392821982y3',\n                            dataForAction: {\n                              type: 'node:0.0.1:local:123445',\n                              data: nodeToSave\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('Update response:', response);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              this.setState({\n                saving: false\n              })\n              \n              return resolve({\n                type: 'node:...',\n                data: response.data.actionResponses[0]\n              });\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              alert('Failed');\n              \n              this.setState({\n                saving: false\n              })\n              \n            }\n            \n          })\n        }\n        \n        @autobind\n        runAction(){\n          return new Promise(async (resolve, reject)=>{\n            try {\n                  \n              // code is MEANT TO BE RUN LOCALLY (on browser)!! \n              // - the local Second requests \"what code should I run for this command?\" \n              //   - context of this Second matters!! \n              //   - assumed to have capabilities like ui/voice/touch/etc. \n              \n              this.setState({\n                runningAction: true\n              });\n              \n              // get Nodes for INPUT to actionCodeNode \n              // - run preParse (should NOT return falsey!) \n              let nowBlockArray = this.props.node.data.now;\n              let nowText = nowBlockArray[1].join(' ');\n              \n              // build commandNode (using new text) first\n              let prevCommandNodeData = this.props.node.data.previous.data; \n              let newWordArray = [];\n              let newWordNodes = [];\n              \n              // iterate through new text (connected to wordNodeId by index/idx) \n              nowBlockArray[1].forEach((textPhrase,idx)=>{\n                let oldNodeForWord = prevCommandNodeData.command.wordNodes[idx];\n                let newWordNode = universe.lodash.clone(oldNodeForWord); // clone _id and type \n                delete newWordNode.data;\n                let words = textPhrase.split(' ');\n                newWordNode.data = textPhrase;\n                newWordNodes.push(newWordNode);\n                words.forEach((word,wordIdx)=>{\n                  newWordArray.push({\n                    nodeId: newWordNode._id,\n                    text: word\n                  });\n                })\n              });\n                    \n              let newCommandNode = {\n                type: this.props.node.data.previous.type,\n                data: {\n                  preParseCodeNode: prevCommandNodeData.preParseCodeNode,\n                  actionCodeNode: prevCommandNodeData.actionCodeNode,\n                  command: {\n                    text: nowText,\n                    wordArray: newWordArray,\n                    wordNodes: newWordNodes\n                  }\n                }\n              };\n              \n              console.log('newCommandNode:',newCommandNode);\n              \n              // get code nodes \n              await this.fetchCodeNodes();\n              console.log('allUserCommandCodeNodes', this.state.allUserCommandCodeNodes);\n              \n              // Todo: get latest Code (by key) \n              // - currently caching the code in the request and directly using that! \n              let latestCode1 = universe.lodash.find(this.state.allUserCommandCodeNodes,n=>{\n                return n.data && n.data.key == newCommandNode.data.preParseCodeNode.data.key;\n              });\n              let preParseResult = await universe.runInVM(latestCode1, {\n                type: 'input_for_preparse:..',\n                data: {}\n              });\n              \n              if(preParseResult !== true){\n                console.log('preParseResult not TRUE');\n                return false;\n              }\n              \n              console.log('Running action!');\n              let latestCode2 = universe.lodash.find(this.state.allUserCommandCodeNodes,n=>{\n                return n.data && n.data.key == newCommandNode.data.actionCodeNode.data.key;\n              });\n              let actionResult = await universe.runInVM(latestCode2, {\n                type: 'input_for_action:..',\n                data: {}\n              });\n              \n              \n              this.setState({\n                runningAction: false\n              });\n              \n              \n              // expecting actionResult to be a react component!!!\n              // - could also be voice, so we should read it out? \n              //   - should check other events /permissions\n              console.log('actionResult:', actionResult);\n              switch(actionResult.type){\n                case 'react_component:0.0.1:local:98912hd89':\n                  this.props.handleActionComponent(newCommandNode, actionResult.data);\n                  break;\n                \n                default:\n                  console.error('Unkown actionResult type!');  \n                  return false;\n                  \n              }\n              \n              return false;\n              \n          \n              // let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n              //   type: 'standard_capability_action:0.0.1:local:298j291bs',\n              //   data: {\n              //     action: 'send',\n              //     options: {\n              //       ExternalIdentityNode: this.props.state.OwnerSecondExternalIdentityNode,\n              //       RequestNode: {\n              //         type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n              //         data: {\n              //           actions: [\n              //             {\n              //               matchActionType: 'run_user_command:0.0.1:local:2090239223323sfd',\n              //               dataForAction: {\n              //                 type: 'user_command:..',\n              //                 data: this.props.node\n              //               }\n              //             }\n              //           ]\n                        \n              //         }\n              //       }\n              //     }\n              //   }\n              // });\n              \n              // // let nodes = universe.lodash.find(response.data.actionResponses[0].data[0].nodes,{type: 'code:0.0.1:local:32498h32f2'});\n              // let nodes = response.data.actionResponses[0].data;\n              \n              // let privateNode = nodes[0];\n              // console.log('PrivateNode:', privateNode);\n              \n              // // let componentNode = await universe.runInVM(result[0],{});\n              // this.props.setState({\n              //   privateNode\n              // })\n              \n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n            }\n          });\n        }\n        \n        \n        render(){\n          \n          // [\"type,type\",[\"str1\",\"str2 str3\"]]\n          let nowBlockArray = this.props.node.data.now;\n          let previousCommandNode = this.props.node.data.previous;\n          \n          \n          let wordArray = previousCommandNode.data.command.wordArray;\n          let wordNodes = previousCommandNode.data.command.wordNodes;\n          let wordNodesById = {};\n          wordNodes.forEach(wn=>{\n            wordNodesById[wn._id] = wn;\n          })\n          \n          return (\n            <div style={{padding:'4px 0 4px 14px',borderBottom:'1px solid #eee',position:'relative',clear:'both'}}>\n            \n              <div className=\"pull-right\">\n              \n                <button className={\"button is-info is-small \" + (this.state.runningAction ? 'is-loading':'')} onClick={this.runAction}>\n                  Run Action\n                </button>\n                &nbsp;\n                <button className=\"button is-danger is-small pull-right\" onClick={this.handleDeleteMatch}>\n                  <span className=\"delete is-small\"></span>\n                </button>\n                \n              </div>\n              \n              <div className=\"choose-preparse-code\" style={{margin: '2px 0'}}>\n                Context/Scenario: <span style={fakeButton}>{previousCommandNode.data.preParseCodeNode.data.note}</span>\n              </div>\n              \n              <div className=\"editing-phrase-holder\" style={{margin: '2px 0'}}>\n                Command: \n                {\n                  nowBlockArray[1].map((textPhrase,idx)=>{\n                    \n                    // USING \"NOW\" WORDS INSTEAD of PREVIOUS wordArray!!!\n                    \n                    // get the correct type from the wordArray (previous) \n                    let prevWordNode = wordNodes[idx];\n                    \n                    // background color? \n                    let backgroundColor = 'white';\n                    let fontWeight = 'normal';\n                    if(prevWordNode._id){\n                      backgroundColor = universe.Please.make_color({seed: prevWordNode._id})\n                    }\n                    // // selected?\n                    // if(this.state.selectedArr){\n                    //   if(idx >= this.state.selectedArr[0] && idx <= this.state.selectedArr[1]){\n                    //     fontWeight = 'bold';\n                    //   }\n                    // }\n                    \n                    let tooltip = prevWordNode.type; // could also use nowBlockArray (split the string) \n                    \n                    return (\n                      <div \n                        key={idx}\n                        className=\"word-in-phrase tooltip-holder\" \n                        style={{backgroundColor, fontWeight, padding: '4px'}}\n                        onClick={e=>this.handleClickWord(word, idx)}\n                      >\n                        <span className=\"tooltip-trigger\">\n                          {textPhrase}\n                        </span>\n                        <div className=\"tooltip\">\n                          {tooltip}\n                        </div>\n                      </div>\n                    )\n                  })\n                }\n              </div>\n              \n              <div className=\"choose-action-code\" style={{margin: '2px 0'}}>\n                Action: <span style={fakeButton}>{previousCommandNode.data.actionCodeNode.data.note}</span>\n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      const fakeButton = {\n        display: 'inline-block',\n        padding: '2px',\n        borderRadius: '2px',\n        border: '1px solid #ccc'\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()"
  },
  "active": true,
  "createdAt": 1513884211402,
  "updatedAt": 1514406733403
}